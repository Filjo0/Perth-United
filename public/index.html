<script type="text/babel">
    // --- CRITICAL: Wait for React Query to load ---
    if (!window.ReactQuery) {
        console.error("React Query failed to load from CDN");
        throw new Error("React Query not loaded");
    }

    // --- Setup ---
    const { useState, useEffect, useMemo } = React;
    const { QueryClient, QueryClientProvider, useQuery } = window.ReactQuery;

    const queryClient = new QueryClient();
    const API_BASE_URL = "";

    // --- API Fetching Functions ---
    const fetchAllStats = async () => {
        const res = await fetch(`${API_BASE_URL}/api/stats`);
        if (!res.ok) throw new Error('Network response was not ok');
        return res.json();
    };

    // --- REST OF YOUR CODE (UNCHANGED) ---
    function PlayerStats() {
        const { data, isLoading, error } = useQuery({
            queryKey: ['stats'],
            queryFn: fetchAllStats
        });

        const [sortBy, setSortBy] = useState('goals');

        if (isLoading) return <div className="loading">Loading Players...</div>;
        if (error) return <div className="error">Error loading stats: {error.message}</div>;

        const players = data?.players || [];

        const sortedPlayers = useMemo(() => {
            return [...players].sort((a, b) => {
                return (b[sortBy] || 0) - (a[sortBy] || 0);
            });
        }, [players, sortBy]);

        return (
            <div>
                <div className="nav">
                    <button className={sortBy === 'goals' ? 'active' : ''} onClick={() => setSortBy('goals')}>Goals</button>
                    <button className={sortBy === 'assists' ? 'active' : ''} onClick={() => setSortBy('assists')}>Assists</button>
                    <button className={sortBy === 'appearances' ? 'active' : ''} onClick={() => setSortBy('appearances')}>Apps</button>
                </div>
                {sortedPlayers.length === 0 && <div className="card"><p>No player stats found.</p></div>}
                {sortedPlayers.map((player, i) => (
                    <div key={player.player_name + player.division} className="card">
                        <h3>[{player.division}] {player.player_name}</h3>
                        <p className="stats">
                            <strong>Goals:</strong> {player.goals} |
                            <strong> Assists:</strong> {player.assists} |
                            <strong> Apps:</strong> {player.appearances}
                        </p>
                    </div>
                ))}
            </div>
        );
    }

    function FixturesCalendar() {
         const { data, isLoading, error } = useQuery({
            queryKey: ['stats'],
            queryFn: fetchAllStats
        });

        if (isLoading) return <div className="loading">Loading Fixtures...</div>;
        if (error) return <div className="error">Error loading fixtures: {error.message}</div>;

        const fixtures = data?.fixtures || [];

        const upcoming = useMemo(() => {
            return fixtures.filter(f => {
                const score_str = String(f.score || '').trim().toLowerCase();
                const isPlayed = score_str.match(/\d+\s*-\s*\d+/);
                return !isPlayed;
            });
        }, [fixtures]);

        return (
            <div>
                {upcoming.length === 0 && (
                    <div className="card">
                        <p>No upcoming fixtures found.</p>
                    </div>
                )}
                {upcoming.map((f, i) => (
                     <div key={f.id || i} className="card">
                        <h3>[{f.division}] Round {f.round}</h3>
                        <p><strong>vs {f.opponent}</strong></p>
                        <p className="stats">{f.date_time} at {f.location || 'TBC'}</p>
                    </div>
                ))}
            </div>
        );
    }

    function App() {
        const [view, setView] = useState('fixtures');

        useEffect(() => {
            try {
                const tg = window.Telegram.WebApp;
                tg.ready();

                document.documentElement.style.setProperty('--tg-bg', tg.themeParams.bg_color || '#ffffff');
                document.documentElement.style.setProperty('--tg-text', tg.themeParams.text_color || '#000000');
                document.documentElement.style.setProperty('--tg-hint', tg.themeParams.hint_color || '#999999');
                document.documentElement.style.setProperty('--tg-button', tg.themeParams.button_color || '#2481cc');
                document.documentElement.style.setProperty('--tg-button-text', tg.themeParams.button_text_color || '#ffffff');
                document.documentElement.style.setProperty('--tg-secondary-bg', tg.themeParams.secondary_bg_color || '#f4f4f4');

                tg.expand();
            } catch (e) {
                console.warn("Telegram WebApp API not found. Running in browser mode.");
            }
        }, []);

        return (
            <div className="container">
                <div className="nav">
                    <button
                        className={view === 'fixtures' ? 'active' : ''}
                        onClick={() => setView('fixtures')}>
                        Fixtures
                    </button>
                    <button
                        className={view === 'stats' ? 'active' : ''}
                        onClick={() => setView('stats')}>
                        Player Stats
                    </button>
                </div>

                {view === 'fixtures' ? <FixturesCalendar /> : <PlayerStats />}
            </div>
        );
    }

    // --- Mount the App ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
        <QueryClientProvider client={queryClient}>
            <App />
        </QueryClientProvider>
    );
</script>
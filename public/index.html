<body>
    <div id="root"></div>

    <!-- LOAD REACT + REACT QUERY WITH DEFER + ONLOAD -->
    <script>
      function loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        script.onerror = () => console.error('Failed to load:', src);
        document.body.appendChild(script);
      }

      // Load in order
      loadScript('https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js', () => {
        loadScript('https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js', () => {
          loadScript('https://cdn.jsdelivr.net/npm/@tanstack/react-query@5/dist/umd/react-query.production.min.js', () => {
            loadScript('https://unpkg.com/@babel/standalone/babel.min.js', () => {
              // Now safe to run your app
              const appScript = document.createElement('script');
              appScript.type = 'text/babel';
              appScript.textContent = `
                const { useState, useEffect, useMemo } = React;
                const { QueryClient, QueryClientProvider, useQuery } = window.ReactQuery;

                const queryClient = new QueryClient();
                const API_BASE_URL = "";

                const fetchAllStats = async () => {
                  const res = await fetch(\`\${API_BASE_URL}/api/stats\`);
                  if (!res.ok) throw new Error('Network error');
                  return res.json();
                };

                function PlayerStats() {
                  const { data, isLoading, error } = useQuery({ queryKey: ['stats'], queryFn: fetchAllStats });
                  const [sortBy, setSortBy] = useState('goals');
                  if (isLoading) return <div className="loading">Loading...</div>;
                  if (error) return <div className="error">Error: {error.message}</div>;
                  const players = data?.players || [];
                  const sorted = [...players].sort((a, b) => (b[sortBy] || 0) - (a[sortBy] || 0));

                  return (
                    <div>
                      <div className="nav">
                        <button className={sortBy === 'goals' ? 'active' : ''} onClick={() => setSortBy('goals')}>Goals</button>
                        <button className={sortBy === 'assists' ? 'active' : ''} onClick={() => setSortBy('assists')}>Assists</button>
                        <button className={sortBy === 'appearances' ? 'active' : ''} onClick={() => setSortBy('appearances')}>Apps</button>
                      </div>
                      {sorted.map(p => (
                        <div key={p.player_name + p.division} className="card">
                          <h3>[{p.division}] {p.player_name}</h3>
                          <p className="stats">
                            <strong>Goals:</strong> {p.goals} |
                            <strong>Assists:</strong> {p.assists} |
                            <strong>Apps:</strong> {p.appearances}
                          </p>
                        </div>
                      ))}
                    </div>
                  );
                }

                function FixturesCalendar() {
                  const { data, isLoading, error } = useQuery({ queryKey: ['stats'], queryFn: fetchAllStats });
                  if (isLoading) return <div className="loading">Loading...</div>;
                  if (error) return <div className="error">Error: {error.message}</div>;
                  const fixtures = data?.fixtures || [];
                  const upcoming = fixtures.filter(f => !String(f.score || '').match(/\\d+\\s*-\\s*\\d+/));

                  return (
                    <div>
                      {upcoming.map(f => (
                        <div key={f.id || f.round} className="card">
                          <h3>[{f.division}] Round {f.round}</h3>
                          <p><strong>vs {f.opponent}</strong></p>
                          <p className="stats">{f.date_time} at {f.location || 'TBC'}</p>
                        </div>
                      ))}
                    </div>
                  );
                }

                function App() {
                  const [view, setView] = useState('fixtures');
                  useEffect(() => {
                    try {
                      const tg = window.Telegram.WebApp;
                      tg.ready(); tg.expand();
                      document.documentElement.style.setProperty('--tg-bg', tg.themeParams.bg_color || '#fff');
                      document.documentElement.style.setProperty('--tg-text', tg.themeParams.text_color || '#000');
                      document.documentElement.style.setProperty('--tg-button', tg.themeParams.button_color || '#2481cc');
                      document.documentElement.style.setProperty('--tg-button-text', tg.themeParams.button_text_color || '#fff');
                      document.documentElement.style.setProperty('--tg-secondary-bg', tg.themeParams.secondary_bg_color || '#f4f4f4');
                    } catch (e) { console.warn('Telegram WebApp not found'); }
                  }, []);

                  return (
                    <div className="container">
                      <div className="nav">
                        <button className={view === 'fixtures' ? 'active' : ''} onClick={() => setView('fixtures')}>Fixtures</button>
                        <button className={view === 'stats' ? 'active' : ''} onClick={() => setView('stats')}>Player Stats</button>
                      </div>
                      {view === 'fixtures' ? <FixturesCalendar /> : <PlayerStats />}
                    </div>
                  );
                }

                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(<QueryClientProvider client={queryClient}><App /></QueryClientProvider>);
              `;
              document.body.appendChild(appScript);
            });
          });
        });
      });
    </script>
</body>